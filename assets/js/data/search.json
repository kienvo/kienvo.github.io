[ { "title": "Windows Qt application deployment with static linking", "url": "/posts/windows-qt5-deploy-static-linking-msys2/", "categories": "raspberry-pi", "tags": "qt, msys2, windows", "date": "2022-11-04 13:00:00 +0800", "snippet": "The problemDeployment might be an unnecessary activity when developing softwares. It been a long time since I started to learn programming, I only make for myself softwares which would be abandon for years later. If you want to run it again, just recompile that code. But what if you want that software to run on your friend computer ? Did you ever copy your executable file to another Windows machine, and it cannot run, but still run on your machine perfectly? Want to install a whole toolchain, copy the code to build on that machine (or 1000 may be) ? But I know someone really do this, Install Visual Studio 2019 on another machine in order to run a C# Winform app he build =]].There a two way to deploy an application to another Windows machine: Dynamic linking - copy numberous .dll files to executable file. Many huge software such as Adobe Photoshop, Google Chrome, etc is using this way. Because shared library alway fast and optimized. But, the size and number of files is large, this would be zipped and ship with a installer. Static linking - “One file to run them all”. All the used library will be linked into a single executable file. But the file would get bigger and quite slow, not to mention compiling and linking speed, terribly slow. Static linking would be easy for low-tech person to use the software, especially when the software is small. I have build a small physic engine for learning purpose, my co-worker find it interesting. He want me to send him this software for his child to play. I didn’t have time until now. This piece of software wasn’t used Qt so this easy to link statically. One of my friends want me to build a motor conntrol pannel application that run on Windows for him. Once again I need to deploy this for him, since the last time I try to statically link my app was not succeed untill now. I’m using Windows as a build machine, at all the time I use Ubuntu.MSYS2msys2 is the only tool that support Qt library, and can install additional library, and natively run on Windows as I consider. You can take a look at [msys2 packages], it seem like almost every open source library which could installed on Linux, were compiled for msys2 and supported cross platform too. I’m doing the development on Linux then using Windows and msys2 to build the releases. Sorry, I didn’t use Qt Creator.MSYS2 have mingw-w64-x86_64-qt5-base contain the base of Qt5 library. It have multiple extra package for multiple purpose. Especially mingw-w64-x86_64-qt5-static, contain static library and utility for linking.For a normal build, you need 4 packages msys-base make mingw-w64-x86_64-gcc mingw-w64-x86_64-qt5And for statically linking, one additonal package mingw-w64-x86_64-qt5-static msys2 uses pacman, so using it is similar to Arch-based distros pacman Install package: pacman -Sy &amp;lt;package-name&amp;gt; List installed packages pacman -Qe Statically linking QtAs default, qmake will perform a normal build. To specify a static build you need 2 things to done: Add CONFIG += -static to qmake’s .pro file. Temporary add qt5-static directory to PATH environment with highest priority: PATH=/mingw64/qt5-static/bin:$PATHYou can confirm that qmake generated a statically-build Makefile when run make:nhung@DESKTOP-7ESDEUJ MINGW64 /g/doan-thaibinh$ echo $PATH # This is my configured PATH/mingw64/qt5-static/bin:/mingw64/bin:/usr/local/bin:/usr/bin:/bin:/c/Windows/System32:/c/Windows:/c/Windows/System32/Wbem:/c/Windows/System32/WindowsPowerShell/v1.0/:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perlnhung@DESKTOP-7ESDEUJ MINGW64 /g/doan-thaibinh$ make # An example when makemake -f Makefile.Releasemake[1]: Entering directory &#39;/g/doan-thaibinh&#39;g++ -c -fno-keep-inline-dllexport -O2 -std=gnu++11 -Wall -Wextra -Wextra -ffunction-sections -fdata-sections -fexceptions -mthreads -DUNICODE -D_UNICODE -DWIN32 -DMINGW_HAS_SECURE_API=1 -DQT_NO_DEBUG -DQT_CHARTS_LIB -DQT_WIDGETS_LIB -DQT_QUICK_LIB -DQT_GUI_LIB -DQT_QMLMODELS_LIB -DQT_QML_LIB -DQT_NETWORK_LIB -DQT_CORE_LIB -DQT_NEEDS_QMAIN -I. -IC:/msys64/mingw64/qt5-static/include -IC:/msys64/mingw64/qt5-static/include/QtCharts -IC:/msys64/mingw64/qt5-static/include/QtWidgets -IC:/msys64/mingw64/qt5-static/include/QtQuick -IC:/msys64/mingw64/qt5-static/include/QtGui -IC:/msys64/mingw64/qt5-static/include/QtQmlModels -IC:/msys64/mingw64/qt5-static/include/QtQml -IC:/msys64/mingw64/qt5-static/include/QtNetwork -IC:/msys64/mingw64/qt5-static/include/QtCore -Ibuild/moc -I/include -IC:/msys64/mingw64/qt5-static/share/qt5/mkspecs/win32-g++ -o build/obj/main.o main.cpp... # ContinuedBy now, the executable file could run on any Windows machine with a bit slower than dynamic executable file." }, { "title": "Lỗi console uart trên rpi3b+", "url": "/posts/rpi3b+undervoltage-uart-console/", "categories": "raspberry-pi", "tags": "raspberry-pi, rpi3b+, console, uart, under-voltage, linux", "date": "2022-10-11 13:00:00 +0800", "snippet": "LỗiKhi sử dụng rpi3b+ với nguồn usb laptop hoặc mấy loại củ sạc dỏm thì console uart của rpi bị nhảy kí tự, không thể đánh lệnh hoặc không thể đọc được.Nguyên nhânMấy củ sạc dỏm hay nguồn usb laptop không đủ dòng (hoặc áp) cho rpi. Chắc là docố ý thiết kế, chứ 5v đưa vào cpu thì vẫn phải hạ xuống 1.8v và 0.9v. Có thể đây là 1 tính năng để người dùng mua hàng từ Raspberry Pi Foundation.Cách khắc phụcSử dụng nguồn xịn, lọc nhiễu kĩ. Như tôi thử với củ sạc Xiaomi chạy ngon lành, cần đeo’ gì nguồn chính hãng Raspberry Pi.Cách thứ 2, khi không muốn hoặc không có nguồn xịn, đó là giảm core_freq từ 300 xuống 250. Chỉ cần thêm dòng core_freq=250 vào cuối file config.txt hoặc sửa core_freq=300 thành core_freq=250. Mỗi distro linux cho arm sẽ có file config.txt ở 1 nơi khác nhau, nhưng thông thường là ở /boot. Như tôi đang xài ubuntu bionic cho rpi3b+, file config có đường dẫn /boot/firmware/config.txt nhưng file config này có include 2 file khác là /boot/firmware/usercfg.txt và /boot/firmware/syscfg.txt nên tôi thêm core_freq=250 vào file usercfg.txt." }, { "title": "Makefile tiếng Việt", "url": "/posts/makefile-tieng-viet-101/", "categories": "build-system", "tags": "makefile", "date": "2022-09-03 15:00:00 +0800", "snippet": "IntroductionThứ đưa tôi đến với Makefile là OSdev. Với tuổi trẻ bồng bột, nghĩ mình có thể build 1 hệ điều hành from scratch (thật ra là có thể). Tôi bỏ dở hệ điều hành của mình khi nó vừa đọc xong bàn phím và ghi lên màn hình :)).Trước khi đến với OSdev tôi đã làm việc với một số MCU 8051 và AVR. Xài Keil C (crack - điều hiển nhiên nếu ở VN) để biên dịch cho 8051, xài AVR Studio rồi đến Atmel Studio (sau là Microchip Studio) cho AVR. Vì tôi cảm thấy vô cùng tội lỗi khi xài đồ crack nên không lâu sau chuyển hoàn toàn sang dùng AVR với Atmel Studio :)). Tất nhiên là 8051 có SDCC nhưng tối lúc đó “chưa đủ tuổi” để xài SDCC (xời, tuổi gì xài SDCC :D).Atmel Studio vỏ Visual Studio, ruột Eclispe, lõi avr-gcc. Sau khi trở về từ OSdev tôi có thể tự mình config các build flag cho toolchain trong Eclipse của Atmel Studio, đặc biệt là macro F_CPU. Thề, F_CPU đặt trong main.c đeo’ bao giờ mà build ra nhận giá trị đúng. Bởi, F_CPU cần phải đặt là global macro thì tất cả các file .c .h mới nhận được giá trị đúng. Đến khi tôi tìm được flag -D của gcc thì mọi chuyện được giải quyết. Từ lúc đó tôi vẫn sử dụng toolchain config (Project properties) để config F_CPU cho project của mình, cho tới khi tìm được chân ái của cuộc đời mình là Makefile.Sơ lược gcc, toolchain và quá tình biên dịch và liên kếtGCC là một trình biên dịch của GNU, hỗ trợ nhiều nền tảng khác nhau từ phần cứng cho tới hệ điều hành. Với phần cứng, dễ thấy nhất là arm-none-eabi-gcc hay dùng lập trình cho STM32, hay avr-gcc cho AVR, với các SoC ARM chạy linux ta có arm-linux-gnueabihf-gcc,… GCC là thành phần chính của GNU toolchain, là trình biên dịch chuẩn cho hầu hết các dự án của GNU và cả Linux.Toolchain là một tập hợp các công cụ để tạo ra phần mềm. Một công cụ lấy input từ công cụ trước đó để tạo ra output, output này trở thành input cho công cụ tiếp theo, tạo thành một chuỗi (chain). Các thành phần trong GNU toolchain: GNU make: công cu quản lí và tự động hóa quá trình build GCC: trình biên dịch glibc: thư viện gồm: header file, thư viện, loader GNU binutils: tập hợp các công cụ gồm: linker, assembler,… GNU Bison: trình phân tích cú pháp GNU m4: trình xử li macro GDB: trình gỡ lỗi GNU Libtool: công cụ thư viên động.Biên dịch và liên kết một file thực thi:Trong ảnh trên tôi đã lược bỏ đi quá trình preprocess và assembly vì trong bài này tôi không tập trung vào quá trình biên dịch file C. Các file .c sẽ được biên dịch thành các file .o, sau đó các file này được liên kết với một số thư viện (etc. glibc) và thêm vào một số phần code startup (etc. crt.a).Mục tiêuTrong giai đoạn nghiên cứu và phát triển đam mê, tôi quen rất nhiều người bạn, những người có khả năng lập trình nhưng vẫn sử dụng IDE, một số người bày tỏ mong muốn tìm hiểm về Makefile nhưng không có thời gian, không tìm được tài liệu chất lượng (tiếng Việt), không đủ trình độ nghiên cứu tài liệu tiếng Anh cho một vấn đề cụ thể.Tôi mong muốn viết bài này cho mọi người cùng học hỏi và để tra lại khi cầnthiết. Vì kiến thức tích lũy bao năm qua, tôi sợ một ngày nào đó mình sẽ quêndần đi. Tôi định viết bài này rất lâu rồi nhưng vì lười. Tranh thủ kì hè năm 2 rảnh rỗi ngồi viết dần, để tích lũy bài viết lên blog.Vấn đềKhi viết bài này, tôi hay vấp phải vần đề trứng hay gà, bởi vì kiến thức tôitrình bày trong một phần yêu cầu kiến thức trong phần khác và ngược lại. Tôi giảsử bạn có bootstrap kiến thức của một trong 2 phần đó .Tôi sẽ trình bày theohướng bottom-up, đó là đi từ vấn đề cốt lõi tại sao sinh ra Makefile.Đặt vấn đềGiả sử, khi lập trình, với C, bạn có thể code mọi thứ trên 1 file .c, nhưng sẽ khó khăn khi maintain Một file .c hàng chục nghìn dòng tốn thời gian để build hơn 1 file có ít dòng. Chỉ cần sửa 1 lỗi nhỏ nhưng phải build lại toàn bộ file. Quá trình maintain lại muốn sử dụng thư viện ngoài, .h .cHướng giải quyếtCó 1 cách giải quyết đó là chia file main.c thành các file .c, rồi build các file .c thành .o. Việc này có thể thực hiện dễ dàng bằng shell script.Giả sử tôi có 3 file foo0.c, foo1.c và main.c, tôi muốn build 3 file này thành 1 file thực thi.// main.c#include &amp;lt;stdio.h&amp;gt;#include &quot;foo0.h&quot;#include &quot;foo1.h&quot;int main() { foo0_func(); foo1_func(); return 0;}// foo0.c#include &amp;lt;foo0.h&amp;gt;void foo0_func() { printf(&quot;printf from foo0.c&quot;);}// foo1.c#include &amp;lt;foo1.h&amp;gt;void foo0_func() { printf(&quot;printf from foo1.c&quot;);}// cùng với 2 file:// foo0.h#include &amp;lt;stdio.h&amp;gt;void foo0_func();// foo1.h#include &amp;lt;stdio.h&amp;gt;void foo1_func();Build các file .c thành .o bằng gcc, link các file .o thành file thực thi$ gcc foo0.c -c # biên dịch foo0.c thành foo0.o$ gcc foo1.c -c # biên dịch foo1.c thành foo1.o$ gcc main.c -c # biên dịch main.c thành main.o$ gcc main.o foo0.o foo1.o # link các file .o thành file thực thi a.outMặc định gcc sẽ link 1 file .c thành file thực thi. Cờ -c để gcc biết rằng chỉcần biên dịch ra file .o mà không cần link thành file thực thi. Nếu không có lỗigì xảy ra thì 3 file là foo0.o, foo1.o, main.o và a.out sẽ được tạo ra trong thưmục chứa file .c.Việc build từng file .c thành từng file .o vấp phải một vấn đề triết họcmang tên trứng hay gà. Bởi vì trình biên dịch chỉ biên dịch 1 file mỗi lần, màtrong file đó chứa lời gọi đến hàm trong 1 file .c khác. Cách giải quyết đó làgán một tên ảo cho hàm đó, giả định hàm đó sẽ có đâu đó trong danh sách các hàmtrong quá trình link. Hay gọi ngắn là prototype hay chung quy hơn là khaibáo (declaration). Ví dụ khi biên dịch main.c main.c chứa 2 lời gọi hàm đó là foo0_func() và foo1_func(). Hai hàm nàyđều nằm trong các file khác, để trình biên dịch biết rằng 2 hàm này nằm ở đâuđó ngoài kia, những vẫn có một điểm nào đó để lời gọi hàm này trỏ tới, ta khaibáo 2 hàm này trong main.c, hay #include fooX.h. Sau khi biên dịch main.osẽ có 2 lời gọi hàm chưa được định nghĩa, đợi đến lúc link, 2 lời gọi hàm nàysẽ trỏ tới phần thân hàm trong fooX.c.Để dễ hình dung hơn, bạn có thể dùng nm - công cụ để list symbols từ file object (.o). nm là 1 công cụ trong bộ binutils, rất hữu ích trong việc trích xuất và xem nội dung file thực thi cũng như file object. Chạy nm main.o foo1.o foo0.o để list các symbol trong 3 file .o trên:$ nm main.o foo1.o foo0.omain.o: U foo0_func U foo1_func0000000000000000 T mainfoo1.o:0000000000000000 T foo1_func U putsfoo0.o:0000000000000000 T foo0_func U putsTa có thể thấy output của nm chia thành 3 cột: giá trị, loại, tên theo thứ thụ từ trái sang phải. Với output trên, có 2 loại symbol là U và T. U nghĩa là “undefined”, symbol chưa được định nghĩa (hay chưa có thân hàm). T nghĩa là “text”, symbol nằm trong .text sections, hay hiểu đơn giản là symbol này là một hàm, giá trị của nó là địa chỉ của hàm.Đối với main.o, 2 hàm foo0_func(), foo1_func() chưa được định nghĩa, mong đợi được định nghĩa khi link.Đối với foo0.o, hàm foo0_func(), đã được định nghĩa nhưng và có giá trị là 0, tức là địa chỉ của hàm foo0_func() trong foo0.o là 0. Địa chỉ này sẽ được thay đổi khi các .o link lại với nhau. Hàm puts() chưa được định nghĩa, vì ta dùng hàm printf(), printf() là một hàm wrapper cho puts(). Hàm puts() này sẽ được link với thư viện động khi link. Tương tự với foo1.o.Sau khi link thành file thực thi thì có gì ?Well, còn tùy thuộc vào nền tảng chạy file thực thi đó mà output của nm sẽ khác nhau, vì nó sẽ link với thư viện động của hệ điều hành. Ví dụ, tôi đang sử dụng Linux (Arch Linux btw) và x86_64-pc-linux-gnu để build thành file a.out ở trên. Đây là output khi chạy nm với a.out:$ nm a.out0000000000003df8 d _DYNAMIC0000000000004000 d _GLOBAL_OFFSET_TABLE_0000000000002000 R _IO_stdin_used w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable0000000000002120 r __FRAME_END__0000000000002030 r __GNU_EH_FRAME_HDR0000000000004030 D __TMC_END__000000000000039c r __abi_tag0000000000004030 B __bss_start w __cxa_finalize@GLIBC_2.2.50000000000004020 D __data_start00000000000010e0 t __do_global_dtors_aux0000000000003df0 d __do_global_dtors_aux_fini_array_entry0000000000004028 D __dso_handle0000000000003de8 d __frame_dummy_init_array_entry w __gmon_start__ U __libc_start_main@GLIBC_2.340000000000004030 D _edata0000000000004038 B _end0000000000001184 T _fini0000000000001000 T _init0000000000001040 T _start0000000000004030 b completed.00000000000004020 W data_start0000000000001070 t deregister_tm_clones0000000000001139 T foo0_func000000000000114f T foo1_func0000000000001130 t frame_dummy0000000000001165 T main U puts@GLIBC_2.2.500000000000010a0 t register_tm_clonesTa có thể thấy một mớ symbol lằng nhằng được thêm vào sau khi link thành file thực thi, những symbol này có liên quan tới trình biên dịch và nền tảng thực thi. Bạn có thể google những symbol lằng nhằng kia nếu tò mò.foo0_func, foo1_func, main đã có địa chỉ. Tuy nhiên, địa chỉ này chỉ là tương đối, khi thực thi, file thực thi sẽ được load vào ram và sẽ có địa chi &amp;lt;địa chỉ loader&amp;gt; + &amp;lt;địa chỉ tương đối&amp;gt;.Quay về vấn đề chínhTôi có thể build nhiều file .c thành 1 file thực thi, thế quái nào tôi lại cần Makefile làm gì ? Vấn đề, shell script sẽ chạy từ trên xuống, bất kể file .c có chỉnh sửa chưa, shell script vẫn sẽ build lại file đó. Hãy tưởng tượng bạn có hàng nghìn file .c, mỗi file build mất 5s, bạn chỉ sửa lại một lỗi nhỏ trong 1 file .c bé tẹo, nhưng phải chờ vài tiếng đồng hồ để build lại cả project. Đó là lúc Makefile nhảy vào.Make, makefile là gì ?Make là công cụ tự động build lại những file .c đã có sự thay đổi. Make có thể sử dụng không chỉ trong lập trình, có thể sử dụng bất cứ đâu mà file output cần phải tự động update khi những file input có sự thay đổi.Khi chạy make, make sẽ tìm thư mục hiện tại có file tên là Makefile, makefile hoặc GNUmakefile để tìm cách build đã vẽ ra trong những file đó. Nếu không tìm thấy makefile nào, make sẽ mặc định chạy implicit rule.Nếu bạn cảm thấy bài post này chán, nhưng vẫn muốn tìm hiểu vê make, here you go, make.RulesRule có dạng:target … : prerequisites … recipe … … target thông thường là file, được tạo ra khi rule này chạy, giống kiểu output. prerequisites là một hoặc nhiều file input cần để tạo ra file target. recipe là hành động tạo ra file target, có thể là một lệnh hoặc nhiều lệnh, trên cùng một dòng hoặc nhiều dòng. Lưu ý: Cần phải đặt một dấu tab trước môi dòng recipe, thì make mới hiểu đó là dòng recipe.Thông thường, recipe trong rule sẽ thực thi, để tạo ra target, khi có bất cứ file nào thay đổi ở prerequisites. Rule có thể có prerequisites hoặc không.Rule giải thích cho make, khi nào cần build lại file target (prerequisites) và làm sao build được nó (recipe)Đơn giản, recipe sẽ chạy khi rule có: target chưa tồn tại, prerequisites tồn tại, trường hợp này target sẽ được tạo ra, target tồn tại, prerequisites bị thay đổi, trường hợp này target cần update.Quay lại với vấn đề build 3 file foo0.c, foo1.c, main.c. Tôi có makefile mẫu:# Thêm foo0.h và foo1.h để chắc chắn 2 file này tồn tại để # main.c có thể include được. 2 file này có thể thêm vào prerequisites# hoặc khôngmain.o: main.c foo0.h foo1.h gcc main.c -o main.o -cfoo0.o: foo0.c foo0.h gcc foo0.c -o foo0.o -cfoo1.o: foo1.c foo1.h gcc foo1.c -o foo1.o -c# Linkingexample.elf: main.o foo0.o foo1.o gcc main.o foo0.o foo1.oKhi chạy make example.elf:$ make example.elf gcc main.c -o main.o -cgcc foo0.c -o foo0.o -cgcc foo1.c -o foo1.o -cgcc main.o foo0.o foo1.o -o example.elfMake sẽ tìm tới rule example.elf, tìm 3 file prerequisites, nếu 3 file đó chưa được tạo ra thì tìm tới từng rule để tạo ra file đó. Giả sử main.o, make sẽ tìm tới rule main.o, kiểm tra prerequisites, nếu có đủ, chạy recipe, sau khi chạy xong sẽ trở về rule example.elf, kiểm tra prerequisites tiếp theo là foo0.o, cứ tiếp tục như vậy đến khi prerequisites có đủ các file thì recipe của rule example.elf sẽ chạy để tạo ra example.elf.Pattern RulesMakefile ở trên có thể viết gọn hơn dùng Pattern Rules:%.o: %.c gcc $^ -o $@ -c# Linkingexample.elf: main.o foo0.o foo1.o gcc main.o foo0.o foo1.oBất cứ khi nào prerequisites của rule nào đó match với target của pattern rule, thì pattern rule sẽ được thực thi với % là phần còn lại không match sẽ thay thế target và prerequisites. Ví dụ, khi rule example.elf được thực thi, nó tìm main.o, main.o match với %.o: %.c lúc này pattern rule sẽ trở thành main.o: main.c.$^ là biến tự động chứa tên của tất cả prerequisites. $@ là biến tự động chứa tên của target. Ngoài ra còn có $&amp;lt; chứa tên của một prerequisites đầu tiên.Ví dụ: khi match với main.o thì pattern rule sẽ giống như này:main.o: main.c gcc main.c -o main.o -cViệc sử dụng pattern rule giúp makefile đơn giản hơn và dễ quản lí. Mặc định, %.o: %.c là một trong số những Implicit Rule tích hợp sẵn trong make (xem ví dụ 2 Implicit Rule).Implicit ruleVí dụ 1:Thông thường khi chạy make mà không có makefile, make sẽ dùng Implicit rule.Rất hữu ích khi muốn build nhanh một file .c thành file thực thi.#include &amp;lt;stdio.h&amp;gt;int main() { printf(&quot;Test make&quot;); return 0;}Lưu file với tên test.c trong một thư mục không có Makefile. Chạy make test:$ make testcc test.c -o testFile thực thi test sẽ được tạo ra. cc test.c -o test là dòng ngầm định khi build không có makefile. cc là một symlink tới gcc, về cơ bản là giống nhau.Để sửa cc thành gcc hay thêm flag để dòng ngầm định trên trở thành gcc -g test.c -o test chẳng hạn thì ta chỉ cần gán cho các biến ngầm định như CC và CFLAGS:CC = gccCFLAGS = -gOutput khi chạy make test với makefile trên:$ make testgcc -g test.c -o testBạn có thể tra các biến ngầm định tại đâyVí dụ 2:Giả sử, ta có makefile:example.elf: main.o foo1.o foo2.o gcc $^ -o example.elfTa không viết rule nào cho main.o, nhưng makefile sẽ tự động tìm implicit rule cho main.o. Việc chỉnh sửa recipe cho implicit rule này dựa vào implicit variable giống như ví dụ 1. Để biết các implicit rule và cách sắp xếp của implicit variable trong implicit rule ban có thể tra ở đâyPhony targetPhony target chỉ là một cái tên để luôn chạy recipe mỗi khi được gọi, không nhất thiết là một file cần được tạo ra.clean: rm -rf $(OBJS) example.elfTrong ví dụ trên, môi khi chạy make clean, thì recipe sẽ luôn chay. Nhưng trênđường đời tấp nập ta vô tình tạo ra một file tên clean thì make file kiểm tra thư mục hiện tai (working directory) có file clean đã được tạo ra và do không có dependency nên file này đuoc coi như là đã update nên recipe của rule này sẽ không chạy nếu ta chạy make clean. Để khắc phục vấn để này, để recipe này luôn luôn chạy mỗi khi make clean thì ta dùng phony target:.PHONY: cleanclean: rm -rf $(OBJS) example.elfMakefile hoàn chỉnhThông thường, để quản lí project, makefile chỉ cần viết một lần. Các khi thêm một module vào project, ta chỉ cần sửa makefile thêm đường dẫn tới file .c bằng biến SRCS. Các file .o sau khi build sẽ lưu ở một thư mục khác (e.g. build, obj). Dưới đây là makefile mẫu cho một project C:CFLAGS =-g -O0CC = gccSRCS = main.c foo0.c foo1.cOBJS = $(patsubst %.c, %.o, $(SRCS)) # chuyển suffix .c thành .o: OBJS = main.o foo.o foo1.o.PHONY: all cleanall: example.elf # make se mặc định chạy example.elfexample.elf: $(OBJS) $(CC) $(CFLAGS) $^ -o $@# Implicit Rule, cái này có hay không cũng được, nhung ngầm đinh nó sẽ như thế này:# %.o: %.c ## $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&amp;lt;clean: rm -rf $(OBJS) example.elfMột số preset build makefile link với .a (code không có hàm main())Với kiểu build này, người lập trình sẽ code trong một hoặc nhiều hàm, có flow khác với kiểu code trong main() truyền thống. Ví du tiêu biểu nhất là Arduino IDE, người lập trình sẽ code trong setup() và loop(), khi chương trình bắt đầu, sau khi chạy startup (của trình biên dịch), chương trình nhảy vào setup() 1 lần, sau đó nhảy vào một vòng lặp và lặp loop() đến chết. RTOS, SDK của xtensa cho esp8266 cũng theo kiểu này.Mục đích của kiểu link này là đê giấu phần code của hệ thống đi, chỉ để lại phần usercode và API cho người dùng gọi tới. Phần API, system flow sẽ được build trong file .a kia, còn phần usercode sẽ được viết trong 1 vài hàm, khi system flow gọi tới hàm trong usercode thì phần code đó sẽ được thực thi.Dưới đây là makefile cho esp8266 với esp8266 non-os SDK, build trên wsl-ubuntu:XTENSA ?=# Mac and linuxSDK_BASE ?= /mnt/c/otp/Espressif/ESP8266_NONOS_SDKESPTOOL ?= /mnt/c/otp/Espressif/utils/esptool/esptool.py# Windows with unofficial dev kit (default install location is C:/Espressif) SDK_BASE_WIN ?= C:/otp/Espressif/ESP8266_NONOS_SDK ESPTOOL_WIN ?= C:/otp/Espressif/utils/esptool/esptool.pySDK_LIBS := -lc -lgcc -lhal -lphy -lpp -lnet80211 -lwpa -lmain -llwip -lcrypto -ljsonCC := $(XTENSA)xtensa-lx106-elf-gccLD := $(XTENSA)xtensa-lx106-elf-gccAR := $(XTENSA)xtensa-lx106-elf-arLDFLAGS = -nostdlib -Wl,--no-check-sections -u call_user_start -Wl,-static -Xlinker -Map=esp.mapCFLAGS = -g -Wpointer-arith -Wundef -Wl,-EL -fno-inline-functions -nostdlib\\ -mlongcalls -mtext-section-literals -ffunction-sections -fdata-sections\\ -fno-builtin-printf -DICACHE_FLASH\\ -I.LD_SCRIPT = -T$(SDK_BASE)/ld/eagle.app.v6.ldall: main.binmain.bin: main.out xtensa-lx106-elf-objdump -S $&amp;lt; &amp;gt; esp.lss $(ESPTOOL) elf2image $(ESPTOOL_FLASHDEF) main.out -o main main.out: main.a @echo &quot;LD $@&quot; $(LD) -L$(SDK_BASE)/lib $(LD_SCRIPT) $(LDFLAGS) -L$(SDK_BASE)/lib -Wl,--start-group $(SDK_LIBS) main.a -Wl,--end-group -o main.outmain.a: main.o @echo &quot;AR main.o&quot; $(AR) cru main.a main.o rf_init.o main.o: @echo &quot;CC main.c &amp;amp; rf_init.c&quot; $(CC) -I&#39;$(SDK_BASE)/include/&#39; $(CFLAGS) -c main.c -o main.o $(CC) -I&#39;$(SDK_BASE)/include/&#39; $(CFLAGS) -c rf_init.c -o rf_init.o clean: rm -rf *.o *.bin *.a *.outflash: python.exe $(ESPTOOL_WIN) --port \\\\\\\\.\\\\COM3 \\ --baud 480600 \\ write_flash --flash_freq 40m --flash_mode dio --flash_size 32m \\ 0x00000 main0x00000.bin \\ 0x10000 main0x10000.bin \\ 0x3fc000 $(SDK_BASE_WIN)/bin/esp_init_data_default.bin.PHONY: all clean// main.c#include &amp;lt;stdio.h&amp;gt;#include &quot;osapi.h&quot;#include &quot;user_interface.h&quot;static os_timer_t led_timer;static int led_value = 0;void app_init() { os_printf(&quot;Helloo blahbla\\r\\n&quot;);}void user_init(void) { system_init_done_cb(app_init);} Makefile tôi lấy từ 1 project có sẵn, có file rf_init.c nữa nhưng tôi không thêm vào để đỡ rối.Ở main.out: main.a sẽ được link với -lc -lgcc -lhal -lphy -lpp -lnet80211 -lwpa -lmain -llwip -lcrypto -ljson. Sau đó được trích thành file .bin bằng esptool.py.Kết luậnTrên đây là kiến thức cơ bản Makefile cho những người mới bắt đầu, nếu bạn đọc tới đây thì bạn có thể tao bất kì project nào với Makefile kể từ bây giờ, không chỉ là code mà bât cứ project nào có dependency file.Bởi vì giới hạn về thời gian nên bài viết còn rât nhiều thiếu sót, bài viết này cần feedback để hoàn thiện hơn. Feel free to leave comments, tôi sẽ giải đáp thắc mắc và tiếp thu ý kiến từ bạn." }, { "title": "Cross compiling kernel modules", "url": "/posts/cross-compiling-kernel-modules/", "categories": "linux", "tags": "kernel, arm, modules, driver, cross-compile", "date": "2021-11-18 23:27:00 +0800", "snippet": "Just got to compile a driver for ti-ads1220 running with Orange Pi Zero. I’ve figure out some stuff when digging to kernel modules. Below is how I config cross build for my Pi.Target systemOrange Pi Zero running Armbian Bionic 20.02.1 with Linux 5.4.20-sunxiDownload kernel sourceDownload kernel source from kernel.orgThe version of kernel source need to be download, must be exact version of the target system. Otherwise, you would be end up with:My target is linux-5.4.20-sunxi so I downloaded linux-5.4.20.tar.gz. Note that the -sunxi suffix could be add later by .config file.Cross compile toolchainarm-linux-gnueabihf working well for me. On Debian just run:$ sudo apt install gcc-arm-linux-gnueabihfand every things works like a charm. Google it for more information or how to install it on other distro.The kernel build configThe build configuration must be exact the same configuration of our target system.You can get a copy from a running system: /proc/config.gz (the file is zipped) /boot/config /boot/config-*In my case, I’m using:~$ zcat /proc/config &amp;gt; .configthen use scp to copy .config from Pi to root folder of kernel source has justdownloaded.Linux kernel suffixTL;DRMy target is linux-5.4.20-sunxi but the source is linux-5.4.20 when I got my first-complete-module-build-without-error output file, I was happy to test it on my Pi. But unfortunately, I got Invalid module format when usinginsmod to load my module. It took me 2 days to figure out what I’m doing wrong.Things is the version magic of my module should match every single letter to the target version. For example, in my case, vermagic of my module was:linux-5.4.20 SMP mod_unload ARMv7 thumb2 p2v8while my Pi is:linux-5.4.20-sunxi SMP mod_unload ARMv7 thumb2 p2v8You can use modinfo for checking vermagic of module and uname -a for a running target.Fix itThe .config file you had taken from the running target, change CONFIG_LOCALVERSION=&quot;&quot; to CONFIG_LOCALVERSION=&quot;-sunxi&quot; before run make and everything should work properly.Build the kernelFrom root folder of kernel source run:# update current .config file$ make ARCH=arm CROSS_COMPILE=&amp;lt;arm-linux-gnueabihf- oldconfig# build $ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4Once done, kernel directory are ready to build your module.Build the moduleA simple Makefileobj-m += mymodule.oKDIR=&amp;lt;your/path/to/kernel/source/root/folder&amp;gt;CROSS=&amp;lt;toolchain compiler&amp;gt;all: make ARCH=arm CROSS_COMPILE=$(CROSS) -C $(KDIR) M=$(PWD) modulesclean: make ARCH=arm CROSS_COMPILE=$(CROSS) -C $(KDIR) M=$(PWD) cleanFrom your module source code, run:$ make" } ]
